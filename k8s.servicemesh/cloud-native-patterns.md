
```
Part 1. The cloud-native context

Chapter 1. You keep using that word: Defining “cloud-native”
            1.1. Today’s application requirements
            1.2. Introducing cloud-native software
            1.3. Cloud-native and world peace
 

Chapter 2. Running cloud-native applications in production
            2.1. The obstacles
            2.2. The enablers
 

Chapter 3. The platform for cloud-native software
            3.1. The cloud(-native) platform evolution
            3.2. Core tenets of the cloud-native platform
            3.3. Who does what?
            3.4. More cloud-native platform capabilities
 

Part 2. Cloud-native patterns

Chapter 4. Event-driven microservices: It’s not just request/response
            4.1. We’re (usually) taught imperative programming
            4.2. Reintroducing event-driven computing
            4.3. My global cookbook
            4.4. Introducing Command Query Responsibility Segregation
            4.5. Different styles, similar challenges
 

Chapter 5. App redundancy: Scale-out and statelessness
            5.1. Cloud-native apps have many instances deployed
            5.2. Stateful apps in the cloud
            5.3. HTTP sessions and sticky sessions
            5.4. Stateful services and stateless apps
 

Chapter 6. Application configuration: Not just environment variables
            6.1. Why are we even talking about config?
            6.2. The app’s configuration layer
            6.3. Injecting system/environment values
            6.4. Injecting application configuration
 

Chapter 7. The application lifecycle: Accounting for constant change
            7.1. Having empathy for operations
            7.2. Single-app lifecycle, multiple-instance lifecycles
            7.3. Coordinating across different app lifecycles
            7.4. Let’s see this in action: Credential rotation and app lifecycle
            7.5. Dealing with ephemeral runtime environments
            7.6. Visibility of app lifecycle state
            7.7. Serverless
 

Chapter 8. Accessing apps: Services, routing, and service discovery
            8.1. The service abstraction
            8.2. Dynamic routing
            8.3. Service discovery
 

Chapter 9. Interaction redundancy: Retries and other control loops
            9.1. Request retries
            9.2. Fallback logic
            9.3. Control loops
 

Chapter 10. Fronting services: Circuit breakers and API gateways
            10.1. Circuit breakers
            10.2. API gateways
            10.3. The service mesh
 

Chapter 11. Troubleshooting: Finding the needle in the haystack
11.1. Application logging
11.2. Application metrics
11.3. Distributed tracing
 

Chapter 12. Cloud-native data: Breaking the data monolith
12.1. Every microservice needs a cache
12.2. Moving from request/response to event driven
12.3. The event log
12.4. Event sourcing
12.5. We’re just scratching the surface

```